Git — это фундаментальный инструмент для любого разработчика и DevOps-инженера. 

### **Основы систем контроля версий. Знакомство с Git**

---

## **◦ Основы систем контроля версий**

**Система контроля версий (Version Control System, VCS)** — это программное обеспечение, которое помогает отслеживать изменения в файлах (чаще всего в исходном коде) с течением времени. Представьте себе "машину времени" для вашего проекта.

**Зачем это нужно?**
*   **Хранение истории:** Вы можете увидеть, кто, когда и какие изменения внёс в код.
*   **Откат изменений:** Если новая функция сломала всё, вы можете легко вернуться к рабочей версии.
*   **Командная работа:** Несколько человек могут работать над одним проектом, не мешая друг другу.
*   **Ветвление и слияние:** Вы можете создавать изолированные "песочницы" (ветки) для разработки новой функционала, а затем безопасно объединять их с основным кодом.
*   **Резервное копирование:** Репозиторий (хранилище кода) является де-факто резервной копией.

**Типы VCS:**
1.  **Локальные (Local VCS):** История изменений хранится на локальном компьютере (например, RCS). Не подходит для командной работы.
2.  **Централизованные (Centralized VCS, CVCS):** Есть один главный сервер, который хранит всю историю файлов. Разработчики "забирают" файлы с него и "возвращают" обратно (например, Subversion, CVS). Недостаток: единая точка отказа (если сервер упадёт, никто не может работать).
3.  **Распределённые (Distributed VCS, DVCS):** Каждый разработчик имеет на своём компьютере **полную копию** репозитория со всей его историей. Это позволяет работать офлайн и предоставляет множество копий для резервирования. **Git и Mercurial** — яркие примеры.

---

## **◦ Работа с проектами в Git**

Чтобы начать работу с Git, ваш проект нужно инициализировать или клонировать.

*   **`git init`** — создаёт новый локальный репозиторий в текущей папке. Появится скрытая папка `.git`, где Git будет хранить всю свою служебную информацию и историю.
*   **`git clone <url-репозитория>`** — создаёт локальную копию удалённого репозитория (например, с GitHub, GitLab или Bitbucket). Это самый частый способ начать работу с существующим проектом.
  *   Пример: `git clone https://github.com/user/project.git`

**Базовый рабочий цикл:**
1.  Вы вносите изменения в файлы в вашей рабочей директории.
2.  Вы подготавливаете файлы, добавляя их в **область подготовленных файлов (Staging Area)** командой `git add`. Это позволяет вам контролировать, какие именно изменения попадут в следующий коммит.
3.  Вы фиксируете изменения командой `git commit`. Это навсегда сохраняет снимок подготовленных файлов в вашей локальной истории.

---

## **◦ Архитектура и объекты Git**

Понимание внутреннего устройства Git помогает не просто заучивать команды, а понимать, что происходит "под капотом".

**Три основных состояния файла в Git:**
1.  **Modified (изменён):** Файл был изменён, но изменения ещё не зафиксированы в Git.
2.  **Staged (подготовлен):** Изменённый файл был отмечен для включения в следующий коммит.
3.  **Committed (зафиксирован):** Данные безопасно сохранены в вашей локальной базе данных.

**Три основные области Git:**
*   **Рабочая директория (Working Directory):** Папка на вашем компьютере, где вы непосредственно работаете с файлами.
*   **Область подготовленных файлов (Staging Area / Index):** Промежуточная область, где вы собираете "комплект" изменений для следующего коммита.
*   **Репозиторий Git (Git Directory / Repository):** Папка `.git`, где хранятся все коммиты и метаданные.

**Основные объекты Git:**
*   **BLOB (Binary Large Object):** Хранит содержимое одного файла.
*   **Tree (Дерево):** Похоже на директорию файловой системы. Хранит ссылки на BLOB-объекты (файлы) и другие tree-объекты (поддиректории).
*   **Commit (Коммит):** Снимок состояния вашего проекта в определённый момент времени. Содержит:
    *   Хэш предыдущего коммита (родителя).
    *   Ссылку на tree-объект, который представляет состояние рабочей директории на момент коммита.
    *   Автора, дату и сообщение коммита.
*   **Tag (Тег):** Постоянная метка для определённого коммита (часто используется для отметки версий, например, `v1.0.0`).

**Важный момент:** Каждый объект в Git идентифицируется своим **SHA-1 хэшем** — уникальным 40-символьным идентификатором, вычисляемым на основе его содержимого.

---

## **◦ Конфигурация Git**

Перед началом работы Git нужно представиться. Настройки хранятся в файлах и могут быть на трёх уровнях:

1.  **`--system`** (системные): Для всех пользователей на компьютере. Файл: `/etc/gitconfig`.
2.  **`--global`** (глобальные): Для вашего пользователя. Файл: `~/.gitconfig` или `~/.config/git/config`.
3.  **`--local`** (локальные): Конкретно для текущего репозитория. Файл: `.git/config` в репозитории. **Имеет наивысший приоритет.**

**Основные команды для настройки:**
```bash
# Установка имени и email (ОБЯЗАТЕЛЬНО СДЕЛАТЬ ПЕРВЫМ ДЕЛОМ)
git config --global user.name "Ваше Имя"
git config --global user.email "your.email@example.com"

# Установка редактора по умолчанию (например, VS Code)
git config --global core.editor "code --wait"

# Просмотр всех настроек
git config --list

# Просмотр конкретной настройки
git config user.name
```

---

## **◦ Основные команды Git**

| Команда | Описание |
| :--- | :--- |
| `git status` | Показывает состояние рабочей директории и staging area: какие файлы изменены, но не подготовлены; какие подготовлены, но не закоммичены. |
| `git add <file>` | Добавляет конкретный файл в staging area. |
| `git add .` | Добавляет все изменённые и новые файлы в текущей директории и поддиректориях в staging area. |
| `git commit -m "Сообщение"` | Фиксирует подготовленные изменения, создавая новый коммит с заданным сообщением. |
| `git log` | Показывает историю коммитов в текущей ветке. |
| `git log --oneline` | Показывает компактную историю (хэш и сообщение). |
| `git diff` | Показывает разницу между рабочей директорией и staging area. |
| `git diff --staged` | Показывает разницу между staging area и последним коммитом. |
| `git restore <file>` | Отменяет изменения в файле в рабочей директории (возвращает к состоянию последнего коммита). |
| `git restore --staged <file>` | Убирает файл из staging area (отменяет `git add`), но сохраняет изменения в рабочей директории. |

---

## **◦ Работа с ветками и слияние**

**Ветка (Branch)** — это подвижный указатель на один из коммитов. По умолчанию в Git создаётся ветка с именем `main` (ранее `master`).

**Зачем нужны ветки?**
Представьте, что вы работаете над новой функцией, которая займёт 2 недели. Вместо того чтобы коммитить незаконченный код в основную ветку, вы создаёте новую ветку. Это изолированная среда, где вы можете спокойно экспериментировать, не затрагивая стабильную основную версию.

| Команда | Описание |
| :--- | :--- |
| `git branch` | Показывает список всех локальных веток. Текущая ветка помечена `*`. |
| `git branch <name>` | Создаёт новую ветку с именем `<name>`. |
| `git checkout <name>` | Переключается на ветку `<name>`. |
| `git switch <name>` | **Более новая и интуитивная команда** для переключения на ветку. |
| `git checkout -b <name>` | Создаёт новую ветку и сразу переключается на неё (удобный алиас). |
| `git switch -c <name>` | Аналог `checkout -b` для команды `switch`. |
| `git merge <name>` | Вливает изменения из ветки `<name>` в **текущую** ветку. |

**Типы слияния (Merge):**
1.  **Fast-Forward:** Если текущая ветка не отходила от той, в которую вы сливаете, Git просто перемещает указатель вперёд. История остаётся линейной.
2.  **Recursive (3-way merge):** Если в обеих ветках были свои коммиты, Git создаёт **коммит слияния**, у которого два родителя. История становится нелинейной.

**Конфликты слияния:** Возникают, когда Git не может автоматически разрешить разницу в одном и том же месте одного и того же файла в двух сливаемых ветках. Вам придётся **вручную** отредактировать файл, убрав маркеры конфликта (`<<<<<<<`, `=======`, `>>>>>>>`), чтобы решить, какой код останется, а затем сделать коммит.

---

## **◦ Работа с историей**

История в Git — это цепочка коммитов. Умение работать с ней — ключевой навык.

| Команда | Описание |
| :--- | :--- |
| `git log` | Основной инструмент. Показывает историю. |
| `git log --oneline --graph --all` | Показывает компактную, наглядную историю всех веток с графом. |
| `git show <commit-hash>` | Показывает информацию о конкретном коммите, включая разницу (diff). |
| `git commit --amend` | **"Исправляет" последний коммит.** Позволяет изменить его сообщение или добавить забытые файлы (если вы сделали `git add` после коммита). **Внимание:** Не используйте для уже отправленных в общий репозиторий коммитов! |
| `git reset <commit-hash>` | Сбрасывает текущую ветку к указанному коммиту. Бывает трёх типов: |
| `git reset --soft <commit>` | Откатывает историю, но оставляет изменения в staging area. |
| `git reset --mixed <commit>` | **(По умолчанию)** Откатывает историю, оставляет изменения в рабочей директории, но НЕ в staging area. |
| `git reset --hard <commit>` | **ОПАСНО!** Полностью откатывает и историю, и рабочую директорию к состоянию на момент указанного коммита. Все незакоммиченные изменения будут безвозвратно удалены. |
| `git revert <commit-hash>` | **Безопасная альтернатива `reset` для общих веток.** Создаёт *новый коммит*, который отменяет изменения, внесённые указанным коммитом. История не переписывается. |

**Важное предупреждение:** Команды, которые **переписывают историю** (`amend`, `reset`), опасны для коммитов, которые уже были отправлены в общий репозиторий. Они вызывают рассинхронизацию у других разработчиков. Для исправления удалённых коммитов всегда используйте `revert`.